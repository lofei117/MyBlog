---
author: lofei117
comments: true
date: 2012-04-26 09:22:09+00:00
layout: post
slug: adapter-design-pattern
title: 设计模式学习之adapter模式
wordpress_id: 75
categories:
- 设计模式
tags:
- Adapter模式
- 设计模式
- 适配器模式
---

先来回顾一下facade模式的特点吧：对系统的一组接口用一个（或多个）更高层的接口封装，提供一个（或多个）统一接口来访问。

然后再来回顾一下设计模式的三个建议：1：按接口编程；2：尽量用聚合代替继承；3：找出变化并封装之；

Adapter模式的定义：将一个类的接口转换成客户希望的另一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的类可以一起工作。

举个例子吧，还是拿泡MM来说吧。我要追一个MM，这个MM很喜欢Apple公司的产品（真够有品位的- -），然后恰巧我有很多苹果的产品，比如iPod， iTouch， iPhone和iPad等（假设，绝对是假设），然后我邀MM到我家来玩这些东西必须先准备好啦，可是我突然发现我的“挨拍”被同事借走了然后一时还不回来， 咋办，眼看MM就要到了啊， 于是我打电话给另外一个哥们把他的山寨“挨拍”拿过来顶一阵了，然后为了不至于被MM发现，我把这个山寨"挨拍" 用我的正品"挨拍"的包装给包装起来，然后弄得像模像样的，看起来跟真的“挨拍”一样。（上帝保佑MM不会发现的）。

可能这个例子不够贴切，但是意思差不多是这个意思了，就是把跟指定接口不匹配的转换成指定接口，使他们能够一起工作（例子中的成为一套Apple系列产品来糊弄MM-_-）。哈哈，相信你能够找到更好的例子的。还有就是这个被转换的对象是要能够正常工作的，也就是对用户来说是一样的，看不出差别的。不然这个山寨挨拍估计就要拍到我脑袋上了，那就是我挨拍了。

ps:那些假冒伪劣产品的厂家很懂这个模式啊~~~~

为什么要使用Adapter模式？

1：希望使用指定的程序或方法，因为它要实现的功能是你需要的；

2：你无法将它直接加入你的程序中；因为它的接口或者调用方式与你原有程序的规范完全不同

（名称和参数列表不同、无法派生它）

所以你需要编写一个接口，通过适配使他们对于客户来说看起来是一样的。(例子中的“挨拍”包装过程才是真正的适配过程， 而不是拿山寨以假乱真）

Adapter模式的关键特征：（摘自《设计模式解析》）

意图：使控制范围之外的一个原有对象与某个接口匹配。

问题：系统的数据和行为都正确，但接口不符。通常用于必须从抽象类派生时。（例子中的山寨“挨拍”是可以用的，但是不是真的Apple产品）

解决方案：Adapter模式提供了具有所需接口的包装类。（将山寨“挨拍”用苹果的挨拍包装起来）

参与者与协作者：Adapter改变了Adaptee的接口，使Adaptee与Adapter的基类Target匹配。这样Client就可以使用Adaptee了，好像它是Target类型。（我改变了山寨“挨拍”的包装，使它跟Apple系列的产品配套，这样就可以拿来忽悠MM了，好像它就是真的挨拍一样）

效果：Adapter模式使原有对象能够适应新的类结构，不受其接口的限制。

实现：将原有类包含在另一个类中。让包含类与需要的接口匹配，调用被包容类的方法。

[![](/assets/images/2012/04/adaptee.png)](/assets/images/2012/04/adaptee.png)



Adapter模式的两种类型：

1：对象Adapter模式。（依赖于一个对象（adapter）包含另一个对象（adaptee））

2：类Adapter模式。（通过多重继承实现）

类Adapter模式的工作原理是创建一个新类，该类同时从两个类继承：

1：从定义其接口的抽象类公开继承；

2：从访问其实现的原有类私有继承；

不过java是不支持多重继承的，所以实现起来的话应该用类聚集实现。这也是设计模式所强调的。不过这样的话就是对象Adapter模式了， 个人是这么理解的。

关于Facade模式和Adapter模式的区别的话，我想这个应该比较明显的吧，一个是是否需要多态、是否需要按指定接口设计， 以及是否需要更简单的接口。共同点的话是都存在既有接口。

大概就这么多了吧， 路漫漫其修远兮，加油~~~

---
author: lofei117
comments: true
date: 2012-04-27 14:01:53+00:00
layout: post
slug: strategy-design-patter
title: 设计模式学习之Strategy模式
wordpress_id: 81
categories:
- 设计模式
tags:
- Strategy模式
- 策略模式
- 设计模式
---

这两天的学习进度很慢啊，心不静。

百度今天宣讲，6号笔试， 不知道自己能不能看完呢。 而且不是看完就完事，还要熟记于心，不然看了也是白看。

好了，废话少说吧，今天来看看Strategy模式。（我的学习过程是按《设计模式解析》一书来的，上面的模式进度是这样的。）

面向对象的三个基本特征：继承、封装和多态。 而设计模式看的最重要的就是这个封装的过程吧。

设计模式的三个要素：1：按接口编程；2：用聚合代替继承；3：超出变化并分装之。

按接口编程，而不要按实现编程，而是抽象出对象的本质，将对象之间的耦合性降低。 一个优秀的模式里面对象应该是高内聚、低耦合的。 也就是对象要对自己负责，而不过度依赖于其他对象。

我有一个泡MM的锦囊，里面有各种各样的泡妞绝招，百试不爽（做白日梦中，请勿打扰）， 包括吃饭、唱歌、看电影等等。 我把它们都放在一起，到要用的时候找就行了。 但是久而久之， 就发现杂乱无章，而且有些MM已经一起吃过饭有自己的口味， 很难从其中找到对应的好策略。 万一比如你跟一个闽家的妹纸去吃四川火锅，把人家辣不高兴了， 然后你就哭吧。

于是我学聪明了， 我把每个MM的喜好都用一个小袋子装起来， 这样跟MM约会的时候，我就知道找到这个MM的袋子， 和MM共处一天的安排就有啦。（ps：貌似我举的这个例子不是很贴切哇， 这其中涉及到好多东西、或者用很多概念都能适配，而不一定就是我要讲的Strategy模式了-_-）

再来思考一下“优先使用对象聚集、对变化进行封装”着两个概念吧。

首先我们来看看泡MM的过程，似乎我们可以发现吃饭、唱歌、看电影这是和每个MM都应该要做的， 所以我把这些抽象成一个类，作为Strategy的基类。然后每个MM又有自己的喜好，比如吃饭口味不同、喜欢的电影的类型不同， 然后我就让每个MM去继承这个基类，实现之。这里可能会有人要说， 不是说尽量用聚集代替继承么？ 你怎么还用继承？ 好吧，笔者也是初学者，见谅见谅。 不过这里的继承是必须的， 不然怎么能把每个MM给特化呢？ 那大家不都一样了吗？ 然后我们再来看看什么地方要用聚集。 别忘了， 我们这可是一个泡MM的秘籍啊， 每个MM再不同， 我这辛苦了大半天弄得可是宝典啊， 所以嘛我把每个MM的特化锦囊聚集在一起， 就成为了一个“泡妞宝典”了， 然后我要用的时候我先找到这个“泡妞宝典”， 然后再找到对应的MM， 怎么样，这下不怕用错秘籍了吧？ 果然是“宝典在手、MM我有”，哈哈哈哈。

ok扯淡扯了半天，回到正题吧。

so给出Strategy策略的定义：定义一系列的算法，将它们一个个封装起来， 并且使它们可以相互替换。Strategy模式使算法可以独立于使用它的客户而变化。（假设单位又来了一个新MM， 相处几天后新的MM锦囊一样收入宝典中，不影响我对其他MM的追求哦。 然后假设万一真不幸丢了一个MM的锦囊， 我也可以找个其他MM的来临时应付一下啦，当然是要接近的才合适）

Strategy模式的几条原则：

1：对象具有职责；（泡妞宝典的职责就是协助我泡MM啦）

2：这些职责不同的具体实现是通过多态的使用完成的。（每个MM都不一样，是因为每个MM都有独立的锦囊哦）

3：概念上相同的算法具有多个不同的实现， 需要进行管理。（不管理的话被偷了或者丢了咋办？你赔我么？）

上面的泡妞秘籍，是按每个MM不同来区分的，当然可能会有人问为什么不按吃饭、看电影等来区分呢？ 首先对象要对自己负责， 你说是拿MM当对象还是拿吃饭当对象呢？ 当然是MM啦， 而且拿吃饭当对象的话， MM与MM之间的耦合性就提高了， 而一个完整的MM的内聚性就变得很弱， 另外还有就是，假若多了一个活动、又多了一个MM，这个锦囊是不是就变得乱起来了呢？（参见《设计模式解析》里该章节的分支蔓延）



Strategy模式的关键特征：（《设计模式解析》）

意图：可以根据所处上下文，使用不同的业务规则或算法。

问题：对所需算法的选择取决于发出请求的客户或者要处理的数据。如果只有一些不会发生变化的算法，就不需要Strategy模式。

解决方案：将对算法的选择和算法的实现相分离。允许根据上下文进行选择。

参与者与协作者:Context、Strategy、ConcreteStrategy。（我、宝典、MM锦囊）

效果：1：定义了一系列的算法；2：减少分支switch和条件语句if的使用；3：必须要以相同的方式调用所有的算法（它们必须具有相同的接口）。各ConcreteStrategy与Context之间的相互作用可能需要在Context中加入获取状态的方法。

实现：让使用算法的类（Context）包含一个抽象类（Strategy）（我有一个宝典），该抽象类有一个抽象方法指定如何调用算法（宝典里有一个目录告诉我选择正确的MM锦囊）。每个派生类按需实现算法。（每个MM的锦囊都有自己的妙计）。

注意，在原型Strategy模式中， 选择所用具体实现的职责由Client对象承担， 并转给Strategy模式的Context对象。

[![](/assets/images/2012/04/1111.png)](/assets/images/2012/04/Strategy.png)



路还很长， 我只能说。

不开心又能怎样。
